/**
 * Router
 * Version: 0.0.1
 * Author: Dmitry Shimkin <dmitryshimkin@gmail.com>
 * License: MIT
 * https://github.com/dmitryshimkin/router
 */
!function(win){"use strict";function createRouter(routerProto){function Router(){}if(supportsObjectCreate)return Object.create(routerProto);Router.prototype=routerProto;var obj=new Router;return Router.prototype=null,obj}function extend(target,obj){return each(obj,function(value,key){target[key]=value}),target}function each(arg,fn,ctx){if("length"in arg)for(var i=0,len=arg.length;len>i;i++)fn.call(ctx,arg[i],i);else for(var key in arg)arg.hasOwnProperty(key)&&fn.call(ctx,arg[key],key);return arg}function isFunction(arg){return"function"==typeof arg}function warn(msg){try{console.warn(msg)}catch(ex){}}function Route(name,pattern){this.name=name,this.pattern=pattern}function RouteEvent(attrs){extend(this,attrs)}function addLocationToQueue(location,inst,props){if(props.redirectCount>Router.MAX_REDIRECT_COUNT)throw props.redirectCount=0,Error("Too many redirects");props.queue.push(location),props.isProcessing||processQueue(inst,props)}function getParams(match){return match?match.slice(1,match.length):[]}function findRoute(routes,name){for(var i=routes.length;i--;)if(routes[i].name===name)return routes[i];return null}function hasRoute(routes,route){return null!==findRoute(routes,route.name)}function getMatchingRoutes(routes,location){var matchingRoutes=[];return each(routes,function(route){var match=route.matches(location);match&&matchingRoutes.push({name:route.name,params:getParams(match)})}),matchingRoutes}function checkRoutes(inst,props){var matchingRoutes=getMatchingRoutes(props.routes,props.location),ctx=props.context||null,activeRoutes=[],toAdd=[],toRemove=[],toUpdate=[];each(props.activeRoutes,function(activeRoute){var newActiveRoute=findRoute(matchingRoutes,activeRoute.name);newActiveRoute?(activeRoutes.push(newActiveRoute),toUpdate.push(newActiveRoute)):toRemove.push({name:activeRoute.name})}),each(matchingRoutes,function(matchingRoute){hasRoute(activeRoutes,matchingRoute)||(activeRoutes.push(matchingRoute),toAdd.push(matchingRoute))}),props.activeRoutes=activeRoutes,isFunction(inst.onRoute)&&(toUpdate.length&&inst.onRoute.call(ctx,new RouteEvent({type:"routechange",routes:toUpdate})),toRemove.length&&inst.onRoute.call(ctx,new RouteEvent({type:"routeend",routes:toRemove})),toAdd.length&&inst.onRoute.call(ctx,new RouteEvent({type:"routestart",routes:toAdd})))}function processQueue(inst,props){var location=props.queue[0];location&&(props.redirectCount++,props.isProcessing=!0,props.location=location,checkRoutes(inst,props),props.queue.shift(),props.queue.length&&processQueue(inst,props),props.isProcessing=!1,props.redirectCount--)}function Router(){function addRoute(name,pattern){props.routes[name]?warn("Route `"+name+"` is already added"):props.routes[name]=new Route(name,pattern)}function getLocation(){return props.location}function setLocation(location){location!==props.location&&addLocationToQueue(location,router,props)}var router=createRouter(Router.prototype),props={queue:[],isProcessing:!1,activeRoutes:[],location:"",redirectCount:0,routes:{}};return router.addRoute=addRoute,router.getLocation=getLocation,router.setLocation=setLocation,router}var supportsObjectCreate=isFunction(Object.create);Route.prototype.matches=function(location){return location.match(this.pattern)},Router.MAX_REDIRECT_COUNT=10,"function"==typeof define&&define.amd?define("Router",Router):"object"==typeof exports?module.exports=Router:win.Router=Router}(this);